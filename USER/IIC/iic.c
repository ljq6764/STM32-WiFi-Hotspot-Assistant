#include "iic.h"
#include "systick.h"
/*********************************************************************************************************
* 函 数 名 : IIC_Start
* 功能说明 : 产生IIC起止信号
* 形    参 : 无
* 返 回 值 : 无
* 备    注 : SCL为高电平期间，SDA由高电平向低电平的跳变。
*********************************************************************************************************/ 
void IIC_Start(void)
{
	IIC_SCL = 1;	//时钟线为高
	IIC_SDA = 1;	//数据线为高
	Delay_Us(5);	//保持，为了产生下沿的动作
	IIC_SDA = 0;	//SCL为高电平期间，拉低SDA，产生起止信号
	Delay_Us(5);
	IIC_SCL = 0;	//占用总线，准备发送数据
	Delay_Us(5);
}
/*********************************************************************************************************
* 函 数 名 : IIC_Stop
* 功能说明 : 产生IIC结束信号
* 形    参 : 无
* 返 回 值 : 无
* 备    注 : SCL为高电平期间，SDA由低电平向高电平的跳变。
*********************************************************************************************************/ 
void IIC_Stop(void)
{
	IIC_SCL = 0;	//SCL为低电平时才能改变SDA的状态
	IIC_SDA = 0;	//拉低SDA，为产生上沿做准备
	Delay_Us(5);
	IIC_SCL = 1;	//在SCL为高电平期间
	IIC_SDA = 1;	//SDA由低向高跳变
	Delay_Us(5);
}
/*********************************************************************************************************
* 函 数 名 : IIC_ACK_NACK
* 功能说明 : 作为接收方时，每个字节（8bit）传输完成后的下一个时钟信号，发起应答或非应答信号
* 形    参 : ack：0应答，1非应答
* 返 回 值 : 
* 备    注 : 在SCL为高电平期间，SDA为低，则表示一个应答信号（ACK）；SDA为高，则表示一个非应答信号（NACK）。
*********************************************************************************************************/ 
void IIC_ACK_NACK(unsigned char ack)
{	
	IIC_SCL = 0;	//SCL为低电平时才能改变SDA的状态
	Delay_Us(1);
	if(!ack)	IIC_SDA = 0;	//产生应答信号
	else 		IIC_SDA = 1;	//产生非应答信号
	Delay_Us(5);
	IIC_SCL = 1;	//拉高SCL，从机读取应答信号
	Delay_Us(5);
	IIC_SCL = 0;	//拉低SCL，准备接收下一个数据
}
/*********************************************************************************************************
* 函 数 名 : IIC_Wait_ACK
* 功能说明 : 作为发送方时，检测从机返回的应答信号
* 形    参 : 无
* 返 回 值 : 0：应答，1：非应答
* 备    注 : 
*********************************************************************************************************/ 
unsigned char IIC_Wait_ACK(void)
{
	unsigned char ErrorCounter = 0;
	IIC_SDA = 1;	//释放数据线
	IIC_SCL = 1;	//拉高SCL
	Delay_Us(5);
	while(IIC_SDAIN)			//SDA被拉低则认为从机给的应答信号
	{
		ErrorCounter++;
		if(ErrorCounter > 250)	//如果过了一段时间数据线还是为高，那么表示非应答信号
		{
			IIC_Stop();
			return 1;
		}
	}
	IIC_SCL = 0;	//拉低SCL，准备下一个数据的接受
	Delay_Us(5);
	return 0;
}
/*********************************************************************************************************
* 函 数 名 : IIC_WriteByte
* 功能说明 : 发送一个字节的数据到IIC总线上
* 形    参 : data：需要发送的数据
* 返 回 值 : 无
* 备    注 : MSB（高位在前）
*********************************************************************************************************/ 
void IIC_WriteByte(unsigned char data)
{
	unsigned char count = 0;
	for(count=0;count<8;count++)
	{
		IIC_SCL = 0;	//SCL为低电平时才能改变SDA的状态
		if(data&0x80)	IIC_SDA = 1;
		else			IIC_SDA = 0;
		data <<= 1;
		Delay_Us(5);
		IIC_SCL = 1;	//数据已准备好，通知从机读取
		Delay_Us(5);
	}
	IIC_SCL = 0;
	Delay_Us(5);
}
/*********************************************************************************************************
* 函 数 名 : IIC_ReadByte
* 功能说明 : 读取IIC总线上的一个字节
* 形    参 : ack：0应答，1非应答
* 返 回 值 : 读取到的数据
* 备    注 : MSB（高位在前）
*********************************************************************************************************/ 
unsigned char IIC_ReadByte(unsigned char ack)
{
	unsigned char count = 0, data = 0;
	IIC_SDA = 1;		//释放数据线
	for(count=0;count<8;count++)
	{
		IIC_SCL = 0;	//通知从机准备数据
		Delay_Us(5);
		IIC_SCL = 1;	//从机已经准备好数据了
		data <<= 1;		//准备一个空位
		data |= !!IIC_SDAIN;	//二值化，确保结果只有1和0
		Delay_Us(5);
	}
	IIC_SCL = 0;
	Delay_Us(5);
	IIC_ACK_NACK(ack);
	return data;
}
